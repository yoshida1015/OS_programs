
課題1

1.実行結果
a is at 0x601044
b is at 0x601040
c is at 0x601034
d is at 0x601038
p is 0x7fff36ef4398
q is 0x7fff36ef4390

2.
BSS    0x601040
data   0x601034
ヒープ  0x7fff36ef4390
からそれぞれ始まっている。

3.
data → BSS → ヒープ

4.p、qはポインタとして定義されているため。


課題2

1.実行結果
In fact(2) before call: &r == 0x7ffcf2537c4c
In fact(1) before call: &r == 0x7ffcf2537c1c
In fact(0): &r == 0x7ffcf2537bec
In fact(1) after call: &r == 0x7ffcf2537c1c
In fact(2) after call: &r == 0x7ffcf2537c4c
fact(2) = 2

2.
アドレスの小さい方へと向かって伸びている。スタックに次々と戻り番地が積まれていくため。

3.
アドレスの大きい方へと向かって伸びている。スタックから再び戻り番地がプッシュされていくため。


課題3

1.実行結果
a = 11, b= 20, c = 33

2.
a,b,cのアドレスは、それぞれ a:0x60102c b:0x601030 c:0x601034 となっていた。
p-1,p,p+1のアドレスはそれぞれ p-1:0x60102c p:0x601030 p+1:0x601034 であった。
pにはbのアドレスがプログラムの中で代入されていて、a,b,cのアドレスはコンパイラで最適化をしていない場合小さい方から連番になっているので、連番であるp-1,p,p+1とアドレスが同じになっている。よってp-1,p+1のアドレスが指す値が書き換えられると、a,cの値が変化する。
int型の値はメモリ４つを使用するので、pを+1,-1するとアドレスは4変化している。

3.
実行結果
a = 10, b= 20, c = 30

理由


課題4

1.実行結果
*p == 10
*p == 100

2.
一つめのprint文では、p=foo()より、関数内で宣言されたxのポインタがpに代入されている。
このとき、foo()の実行が終わると同時に変数xは解放されてしまう。その後、q=bar()が実行され、bar関数内でxの値が書き換えられると、解放されていたxが再び定義され、その後のprint文ではbar関数で指定された値のxのポインタがpに代入されていることになるので、前後のprint文で実行結果が異なるのではないかと考える。


課題5
control hijacked!
